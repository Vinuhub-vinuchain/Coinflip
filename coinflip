<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VinuHub Coinflip</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    body {
      background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
    }
    .coin-container { 
      perspective: 1000px; 
      padding: 1rem; 
      background: rgba(255, 255, 255, 0.05); 
      border-radius: 50%; 
    }
    .coin { 
      width: 20vw; 
      height: 20vw; 
      max-width: 120px; 
      max-height: 120px; 
      min-width: 80px; 
      min-height: 80px; 
      position: relative; 
      transform-style: preserve-3d; 
      transition: transform 1s ease-in-out; 
      border: 2px solid #ffffff; 
      border-radius: 50%;
    }
    .coin.flipping { 
      transform: rotateY(720deg); 
      animation: glow 1s ease-in-out; 
    }
    .coin.heads { 
      transform: rotateY(0deg); 
    }
    .coin.tails { 
      transform: rotateY(180deg); 
    }
    .side { 
      position: absolute; 
      width: 100%; 
      height: 100%; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      backface-visibility: hidden; 
      background: linear-gradient(145deg, #e2e8f0, #ffffff); 
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7); 
    }
    .heads img, .tails img { 
      width: 80%; 
      height: 80%; 
      object-fit: contain; 
    }
    .tails { transform: rotateY(180deg); }
    .pulse { 
      animation: pulse 2s infinite; 
      transition: all 0.3s ease; 
    }
    .pulse:hover { 
      transform: scale(1.05); 
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3); 
    }
    @keyframes pulse { 
      0% { transform: scale(1); } 
      50% { transform: scale(1.05); } 
      100% { transform: scale(1); } 
    }
    @keyframes glow { 
      0% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); } 
      50% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); } 
      100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); } 
    }
    .btn-primary { 
      background: linear-gradient(to right, #4a5568, #718096); 
      transition: all 0.3s ease; 
    }
    .btn-primary:hover { 
      background: linear-gradient(to right, #718096, #a0aec0); 
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3); 
    }
    .btn-secondary { 
      background: linear-gradient(to right, #2d3748, #4a5568); 
      transition: all 0.3s ease; 
    }
    .btn-secondary:hover { 
      background: linear-gradient(to right, #4a5568, #718096); 
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3); 
    }
    .logo { filter: grayscale(100%); width: auto; height: 48px; transition: transform 0.3s ease; }
    .logo:hover { transform: scale(1.1); }
    .card { 
      background: rgba(45, 55, 72, 0.9); 
      backdrop-filter: blur(10px); 
      border-radius: 12px; 
      padding: 1.5rem; 
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); 
    }
  </style>
</head>
<body class="text-white font-sans">
  <div id="root" class="min-h-screen flex flex-col items-center justify-center p-4 sm:p-6 md:p-8">
    <div class="mb-6 sm:mb-8 flex flex-col items-center">
      <img src="https://photos.pinksale.finance/file/pinksale-logo-upload/1759847695513-f915ce15471ce09f03d8fbf68bc0616f.png" alt="VinuHub Logo" class="logo" />
    </div>
    <p class="text-gray-300 text-sm sm:text-base md:text-lg mb-6 sm:mb-8">Flip fate on VinuChain â€“ Feeless & Fair</p>
    <p id="error" class="text-red-400 text-sm sm:text-base mb-4 hidden"></p>
    <div class="w-full max-w-md sm:max-w-lg md:max-w-xl card">
      <div class="mb-6 sm:mb-8">
        <p id="wallet-status" class="text-gray-200 text-sm sm:text-base hidden"></p>
        <p id="contract-balance" class="text-gray-200 text-sm sm:text-base mb-4 hidden">Contract Balance: 0 VIN</p>
        <button id="connect-wallet" class="btn-primary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg pulse w-full text-sm sm:text-base">Connect Wallet</button>
        <button id="disconnect-wallet" class="btn-secondary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg w-full text-sm sm:text-base hidden">Disconnect Wallet</button>
      </div>
      <div id="balance-section" class="hidden mb-6 sm:mb-8">
        <p id="balances" class="text-gray-200 text-sm sm:text-base mb-4">VIN Balance: 0 | Winnings: 0 VIN</p>
        <button id="approve-vin" class="btn-secondary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg w-full mb-4 hidden">Approve VIN</button>
      </div>
      <div class="mb-6 sm:mb-8">
        <label class="block text-gray-200 text-sm sm:text-base mb-2">Bet Amount (VIN)</label>
        <div class="flex gap-2 mb-2">
          <input id="bet-amount" type="number" min="0.1" max="100000" step="0.1" value="0.1" placeholder="Enter amount" class="flex-1 px-3 py-2 bg-gray-700 border border-gray-500 rounded-lg text-white text-sm sm:text-base focus:outline-none focus:border-gray-300 disabled:bg-gray-800 disabled:cursor-not-allowed" disabled />
          <button id="set-max" class="btn-secondary text-white px-4 py-2 rounded-lg text-sm sm:text-base disabled:opacity-50" disabled>Max</button>
        </div>
        <p class="text-gray-300 text-xs sm:text-sm">Min: 0.1 VIN | Max: 100000 VIN</p>
        <p id="bet-error" class="text-red-400 text-xs sm:text-sm mt-1 hidden"></p>
      </div>
      <div class="mb-6 sm:mb-8">
        <label class="block text-gray-200 text-sm sm:text-base mb-2">Choose Side</label>
        <div class="flex gap-2 sm:gap-4">
          <button id="choose-heads" class="flex-1 btn-primary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg text-sm sm:text-base" disabled>Heads</button>
          <button id="choose-tails" class="flex-1 btn-secondary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg text-sm sm:text-base" disabled>Tails</button>
        </div>
      </div>
      <div class="coin-container mb-6 sm:mb-8 mx-auto">
        <div id="coin" class="coin heads">
          <div class="side heads">
            <img src="https://photos.pinksale.finance/file/pinksale-logo-upload/1760517373672-b81d4b93ee4e5dcd9d7463e941d680c4.png" alt="Heads" />
          </div>
          <div class="side tails">
            <img src="https://photos.pinksale.finance/file/pinksale-logo-upload/1760517398339-0e799d5e0f9ab9230cd2fc425ea13ac5.png" alt="Tails" />
          </div>
        </div>
      </div>
      <button id="flip-coin" class="btn-primary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg w-full mb-4 sm:mb-6 text-sm sm:text-base disabled:opacity-50" disabled>Flip Coin</button>
      <button id="withdraw" class="btn-primary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg w-full mb-4 sm:mb-6 text-sm sm:text-base disabled:opacity-50" disabled>Withdraw Winnings</button>
      <div id="share-section" class="mb-6 sm:mb-8 hidden">
        <button id="share-x" class="btn-secondary text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg w-full text-sm sm:text-base">Share to X</button>
      </div>
      <div id="result" class="mb-6 sm:mb-8 p-4 bg-gray-800 rounded-lg hidden"></div>
      <div class="mb-6 sm:mb-8">
        <h2 class="text-xl sm:text-2xl font-bold mb-2 text-gray-100">Recent Flips</h2>
        <ul id="history" class="text-gray-200 text-sm sm:text-base"></ul>
      </div>
      <div>
        <h2 class="text-xl sm:text-2xl font-bold mb-2 text-gray-100">Leaderboard</h2>
        <ul id="leaderboard" class="text-gray-200 text-sm sm:text-base"></ul>
      </div>
    </div>
  </div>
  <script>
    const VINUCHAIN_CONFIG = {
      chainId: "0xCF", // 207 in hex
      chainName: "VinuChain",
      rpcUrls: ["https://rpc.vinuchain.org", "https://vinuchain-rpc.com"],
      nativeCurrency: { name: "VinuChain", symbol: "VC", decimals: 18 },
      blockExplorerUrls: ["https://vinuexplorer.org"]
    };

    const CONTRACT_ADDRESS = "0xD95376dD5E6bc02dfB3D1445352D0395B908ffcf";
    const VIN_TOKEN_ADDRESS = "0x6109835364EdA2c43CaA8981681e75782C13566C";

    const CONTRACT_ABI = [
      "function flip(bool _heads, uint256 _amount) external",
      "function withdraw() external",
      "function playerBalances(address) view returns (uint256)",
      "event FlipResult(address indexed player, bool heads, bool won, uint256 bet, uint256 payout)",
      "event Withdrawal(address indexed player, uint256 amount)"
    ];

    const VIN_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];

    // State variables
    let provider = null;
    let signer = null;
    let contract = null;
    let vinToken = null;
    let account = null;
    let betAmount = "0.1";
    const maxBet = "100000";
    let choice = true;
    let flipping = false;
    let approving = false;
    let isApproved = false;
    let vinBalance = "0";
    let playerBalance = "0";
    let contractBalance = "0";
    let connecting = false;
    let history = [];
    let leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
    let connectLog = [];
    let isUpdatingUI = false;
    let lastWin = null;
    let coinSide = "heads"; // Track final coin side

    // DOM elements
    const connectWalletBtn = document.getElementById("connect-wallet");
    const disconnectWalletBtn = document.getElementById("disconnect-wallet");
    const walletStatusEl = document.getElementById("wallet-status");
    const contractBalanceEl = document.getElementById("contract-balance");
    const balanceSectionEl = document.getElementById("balance-section");
    const balancesEl = document.getElementById("balances");
    const approveVinBtn = document.getElementById("approve-vin");
    const betAmountInput = document.getElementById("bet-amount");
    const setMaxBtn = document.getElementById("set-max");
    const betErrorEl = document.getElementById("bet-error");
    const chooseHeadsBtn = document.getElementById("choose-heads");
    const chooseTailsBtn = document.getElementById("choose-tails");
    const coinEl = document.getElementById("coin");
    const flipCoinBtn = document.getElementById("flip-coin");
    const withdrawBtn = document.getElementById("withdraw");
    const shareSectionEl = document.getElementById("share-section");
    const shareXBtn = document.getElementById("share-x");
    const resultEl = document.getElementById("result");
    const historyEl = document.getElementById("history");
    const leaderboardEl = document.getElementById("leaderboard");
    const errorEl = document.getElementById("error");

    // Sound effects
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let coinSound = null;
    let winSound = null;
    let lossSound = null;
    async function loadSounds() {
      try {
        const coinResponse = await fetch("https://ipfs.io/ipfs/QmZ3K4Y4x1y4Y6Y9Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y/coin-flip.wav"); // Replace with actual IPFS-hosted WAV
        const coinBuffer = await coinResponse.arrayBuffer();
        coinSound = await audioContext.decodeAudioData(coinBuffer);
        const winResponse = await fetch("https://ipfs.io/ipfs/QmZ3K4Y4x1y4Y6Y9Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y/win.wav"); // Replace with actual IPFS-hosted WAV
        const winBuffer = await winResponse.arrayBuffer();
        winSound = await audioContext.decodeAudioData(winBuffer);
        const lossResponse = await fetch("https://ipfs.io/ipfs/QmZ3K4Y4x1y4Y6Y9Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y8Y/loss.wav"); // Replace with actual IPFS-hosted WAV
        const lossBuffer = await lossResponse.arrayBuffer();
        lossSound = await audioContext.decodeAudioData(lossBuffer);
        logConnect("Sounds loaded");
      } catch (err) {
        console.error("Failed to load sounds:", err);
        logConnect(`Failed to load sounds: ${err.message}`);
      }
    }
    function playCoinSound() {
      if (coinSound) {
        const source = audioContext.createBufferSource();
        source.buffer = coinSound;
        source.connect(audioContext.destination);
        source.start(0);
      }
    }
    function playWinSound() {
      if (winSound) {
        const source = audioContext.createBufferSource();
        source.buffer = winSound;
        source.connect(audioContext.destination);
        source.start(0);
      }
    }
    function playLossSound() {
      if (lossSound) {
        const source = audioContext.createBufferSource();
        source.buffer = lossSound;
        source.connect(audioContext.destination);
        source.start(0);
      }
    }

    // Debounce utility
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Log connect step (console only)
    function logConnect(step) {
      const timestamp = new Date().toISOString();
      connectLog = [...connectLog.slice(-5), `[${timestamp}] ${step}`];
      console.log(`Connect: ${step}`);
    }

    // Show/hide element
    function toggleElement(el, show) {
      el.classList.toggle("hidden", !show);
    }

    // Update UI
    function updateUI() {
      if (isUpdatingUI) return;
      isUpdatingUI = true;
      try {
        console.log("Updating UI:", { account, vinBalance, playerBalance, contractBalance, isApproved, betAmount, choice, flipping, approving, coinSide });
        toggleElement(errorEl, !!errorEl.textContent);
        toggleElement(walletStatusEl, !!account);
        toggleElement(contractBalanceEl, !!account);
        toggleElement(balanceSectionEl, !!account);
        toggleElement(approveVinBtn, !!account && !isApproved);
        toggleElement(shareSectionEl, !!lastWin);
        toggleElement(connectWalletBtn, !account);
        toggleElement(disconnectWalletBtn, !!account);
        walletStatusEl.textContent = account ? `Connected: ${account.slice(0, 6)}...${account.slice(-4)}` : "";
        contractBalanceEl.textContent = `Contract Balance: ${contractBalance} VIN`;
        balancesEl.textContent = `VIN Balance: ${vinBalance} | Winnings: ${playerBalance} VIN`;
        approveVinBtn.textContent = approving ? "Approving..." : `Approve ${betAmount} VIN`;
        approveVinBtn.disabled = approving || !account || !validateBet(betAmount);
        betAmountInput.value = betAmount;
        betAmountInput.disabled = !account;
        setMaxBtn.disabled = !account;
        toggleElement(betErrorEl, !!betErrorEl.textContent);
        chooseHeadsBtn.classList.toggle("btn-primary", choice);
        chooseHeadsBtn.classList.toggle("btn-secondary", !choice);
        chooseTailsBtn.classList.toggle("btn-primary", !choice);
        chooseTailsBtn.classList.toggle("btn-secondary", choice);
        chooseHeadsBtn.disabled = !account;
        chooseTailsBtn.disabled = !account;
        coinEl.classList.toggle("flipping", flipping);
        coinEl.classList.toggle("heads", !flipping && coinSide === "heads");
        coinEl.classList.toggle("tails", !flipping && coinSide === "tails");
        flipCoinBtn.textContent = flipping ? "Flipping..." : "Flip Coin";
        flipCoinBtn.disabled = flipping || !account || !!betErrorEl.textContent || approving || !isApproved;
        withdrawBtn.disabled = !account || parseFloat(playerBalance) === 0;
        toggleElement(resultEl, !!resultEl.innerHTML);
        historyEl.innerHTML = history.length === 0 ? "<p class='text-gray-300 text-sm sm:text-base'>No flips yet.</p>" : 
          history.map((flip, i) => `<li key="${i}" class="mb-1">${flip.heads ? "Heads" : "Tails"} - ${flip.won ? "Won" : "Lost"} (${flip.bet} VIN â†’ ${flip.payout} VIN)</li>`).join("");
        leaderboardEl.innerHTML = leaderboard.length === 0 ? "<p class='text-gray-300 text-sm sm:text-base'>No wins yet.</p>" : 
          leaderboard.map((entry, i) => `<li key="${i}" class="mb-1">${entry.player.slice(0, 6)}...${entry.player.slice(-4)} won ${entry.payout} VIN (${new Date(entry.timestamp).toLocaleString()})</li>`).join("");
      } finally {
        isUpdatingUI = false;
      }
    }

    // Validate bet amount
    function validateBet(amount) {
      console.log("Validating bet:", amount);
      const num = parseFloat(amount);
      if (isNaN(num) || num < 0.1) {
        errorEl.textContent = "Minimum bet: 0.1 VIN";
        betErrorEl.textContent = "Minimum bet: 0.1 VIN";
        return false;
      }
      if (num > parseFloat(maxBet)) {
        errorEl.textContent = `Maximum bet: ${maxBet} VIN`;
        betErrorEl.textContent = `Maximum bet: ${maxBet} VIN`;
        return false;
      }
      if (num > parseFloat(vinBalance)) {
        errorEl.textContent = "Insufficient VIN balance";
        betErrorEl.textContent = "Insufficient VIN balance";
        return false;
      }
      errorEl.textContent = "";
      betErrorEl.textContent = "";
      return true;
    }

    // Disconnect wallet
    function disconnectWallet() {
      provider = null;
      signer = null;
      contract = null;
      vinToken = null;
      account = null;
      isApproved = false;
      vinBalance = "0";
      playerBalance = "0";
      contractBalance = "0";
      history = [];
      leaderboard = [];
      lastWin = null;
      coinSide = "heads";
      updateUI();
    }

    // Initialize app
    async function initialize() {
      logConnect("Initializing app");
      if (!window.ethereum || !window.ethereum.isMetaMask) {
        errorEl.textContent = "MetaMask not detected. Please install MetaMask.";
        logConnect("MetaMask not detected");
        connectWalletBtn.disabled = true;
        updateUI();
        return;
      }
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        logConnect("Provider initialized");
        await loadSounds();
        updateUI();
      } catch (err) {
        console.error("Initialization error:", err);
        errorEl.textContent = "Failed to initialize provider: " + err.message;
        logConnect(`Initialization error: ${err.message}`);
        connectWalletBtn.disabled = true;
        updateUI();
      }
    }

    // Check balances
    const checkBalances = debounce(async () => {
      if (!vinToken || !contract || !account) return;
      logConnect("Fetching balances for account: " + account.slice(0, 6));
      try {
        const bal = await vinToken.balanceOf(account);
        vinBalance = ethers.utils.formatEther(bal);
        logConnect("VIN balance: " + vinBalance);
        const playerBal = await contract.playerBalances(account);
        playerBalance = ethers.utils.formatEther(playerBal);
        logConnect("Player balance: " + playerBalance);
        const contractBal = await vinToken.balanceOf(CONTRACT_ADDRESS);
        contractBalance = ethers.utils.formatEther(contractBal);
        logConnect("Contract balance: " + contractBalance);
        updateUI();
      } catch (err) {
        console.error("Balance fetch error:", err);
        errorEl.textContent = "Failed to fetch balances: " + err.message;
        logConnect(`Balance fetch error: ${err.message}`);
        updateUI();
      }
    }, 500);

    // Check allowance
    const checkAllowance = debounce(async () => {
      if (!vinToken || !account || !betAmount) return;
      logConnect("Fetching allowance for betAmount: " + betAmount);
      try {
        const allowance = await vinToken.allowance(account, CONTRACT_ADDRESS);
        logConnect("Allowance: " + allowance.toString());
        isApproved = allowance.gte(ethers.utils.parseEther(betAmount || "0"));
        updateUI();
      } catch (err) {
        console.error("Allowance fetch error:", err);
        errorEl.textContent = "Failed to fetch allowance: " + err.message;
        logConnect(`Allowance fetch error: ${err.message}`);
        updateUI();
      }
    }, 500);

    // Connect wallet
    async function connectWallet() {
      if (!provider) {
        errorEl.textContent = "No provider available. Please install MetaMask.";
        logConnect("No provider available");
        updateUI();
        return;
      }
      connecting = true;
      errorEl.textContent = "";
      logConnect("Starting wallet connection");
      updateUI();
      try {
        const timeout = new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Connection timed out")), 10000);
        });

        logConnect("Checking network");
        const network = await Promise.race([provider.getNetwork(), timeout]);
        logConnect(`Network check complete: chainId=${network.chainId}`);
        if (network.chainId !== 207) {
          logConnect("Switching to VinuChain");
          try {
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: "0xCF" }],
            });
            logConnect("Network switched to VinuChain");
          } catch (switchError) {
            console.error("Switch chain error:", switchError);
            logConnect(`Switch chain error: ${switchError.message}`);
            if (switchError.code === 4902) {
              logConnect("Adding VinuChain");
              try {
                await window.ethereum.request({
                  method: "wallet_addEthereumChain",
                  params: [VINUCHAIN_CONFIG]
                });
                logConnect("VinuChain added");
              } catch (addError) {
                console.error("Add chain error:", addError);
                errorEl.textContent = "Failed to add VinuChain: " + addError.message;
                logConnect(`Add chain error: ${addError.message}`);
                connecting = false;
                updateUI();
                return;
              }
            } else {
              errorEl.textContent = "Failed to switch to VinuChain: " + switchError.message;
              logConnect(`Switch chain error: ${switchError.message}`);
              connecting = false;
              updateUI();
              return;
            }
          }
        }

        logConnect("Testing RPC");
        try {
          await Promise.race([provider.getBlockNumber(), timeout]);
          logConnect("RPC connected");
        } catch (rpcError) {
          console.error("RPC test failed:", rpcError);
          errorEl.textContent = "VinuChain RPC unavailable. Try switching RPCs or check network status.";
          logConnect(`RPC test failed: ${rpcError.message}`);
          connecting = false;
          updateUI();
          return;
        }

        logConnect("Requesting accounts");
        const accounts = await Promise.race([
          window.ethereum.request({ method: "eth_requestAccounts" }),
          timeout
        ]);
        logConnect("Accounts requested");
        signer = provider.getSigner();
        account = accounts[0];
        logConnect("Connected address: " + account);

        logConnect("Initializing contracts");
        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        vinToken = new ethers.Contract(VIN_TOKEN_ADDRESS, VIN_ABI, signer);
        logConnect("Contracts initialized");

        connecting = false;
        checkBalances();
        checkAllowance();
        logConnect("Wallet connection complete");
        updateUI();
      } catch (error) {
        console.error("Wallet connection error:", error);
        errorEl.textContent = error.message.includes("MetaMask") 
          ? error.message 
          : `Failed to connect wallet: ${error.message || "Unknown error"}`;
        logConnect(`Wallet connection error: ${error.message}`);
        connecting = false;
        connectWalletBtn.disabled = false;
        updateUI();
      }
    }

    // Disconnect wallet
    function disconnectWallet() {
      provider = null;
      signer = null;
      contract = null;
      vinToken = null;
      account = null;
      isApproved = false;
      vinBalance = "0";
      playerBalance = "0";
      contractBalance = "0";
      history = [];
      leaderboard = [];
      lastWin = null;
      coinSide = "heads";
      updateUI();
    }

    // Approve VIN
    async function approveVin() {
      if (!vinToken || !signer || !validateBet(betAmount)) return;
      approving = true;
      errorEl.textContent = "";
      logConnect("Approving VIN: " + betAmount);
      updateUI();
      try {
        const amount = ethers.utils.parseEther(betAmount || "100000");
        let gasSettings = {};
        try {
          const feeData = await provider.getFeeData();
          gasSettings = {
            gasLimit: 100000,
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas || ethers.utils.parseUnits("1", "gwei"),
            maxFeePerGas: feeData.maxFeePerGas || ethers.utils.parseUnits("2", "gwei")
          };
        } catch (feeError) {
          console.warn("Failed to fetch fee data, using fallback:", feeError);
          gasSettings = { gasLimit: 100000, gasPrice: ethers.utils.parseUnits("1", "gwei") };
        }
        const tx = await vinToken.approve(CONTRACT_ADDRESS, amount, gasSettings);
        await tx.wait();
        isApproved = true;
        errorEl.textContent = "VIN approved successfully!";
        logConnect("VIN approved");
        updateUI();
      } catch (error) {
        console.error("Approval error:", error);
        errorEl.textContent = error.code === -32603 || error.message.includes("insufficient funds") 
          ? "Approval failed: Insufficient funds for gas. Add VC to your wallet." 
          : "Approval failed: " + error.message;
        logConnect(`Approval error: ${error.message}`);
        approving = false;
        updateUI();
      }
    }

    // Flip coin
    async function flipCoin() {
      if (!contract || !signer || !validateBet(betAmount) || !isApproved) return;
      flipping = true;
      errorEl.textContent = "";
      logConnect("Sending flip transaction: " + (choice ? "Heads" : "Tails") + ", " + betAmount + " VIN");
      updateUI();
      try {
        let gasSettings = {};
        try {
          const feeData = await provider.getFeeData();
          gasSettings = {
            gasLimit: 200000,
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas || ethers.utils.parseUnits("1", "gwei"),
            maxFeePerGas: feeData.maxFeePerGas || ethers.utils.parseUnits("2", "gwei")
          };
        } catch (feeError) {
          console.warn("Failed to fetch fee data, using fallback:", feeError);
          gasSettings = { gasLimit: 200000, gasPrice: ethers.utils.parseUnits("1", "gwei") };
        }
        const tx = await contract.flip(choice, ethers.utils.parseEther(betAmount), gasSettings);
        await tx.wait();
        logConnect("Flip transaction confirmed");
        flipping = true;
        playCoinSound();
        updateUI();
        setTimeout(() => {
          flipping = false;
          updateUI();
        }, 1000); // Match animation duration
      } catch (error) {
        console.error("Flip error:", error);
        errorEl.textContent = error.code === -32603 || error.message.includes("insufficient funds") 
          ? "Flip failed: Insufficient funds for gas. Add VC to your wallet." 
          : "Flip failed: " + error.message;
        logConnect(`Flip error: ${error.message}`);
        flipping = false;
        updateUI();
      }
    }

    // Withdraw
    async function withdraw() {
      if (!contract || !signer) return;
      errorEl.textContent = "";
      logConnect("Withdrawing winnings");
      updateUI();
      try {
        let gasSettings = {};
        try {
          const feeData = await provider.getFeeData();
          gasSettings = {
            gasLimit: 100000,
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas || ethers.utils.parseUnits("1", "gwei"),
            maxFeePerGas: feeData.maxFeePerGas || ethers.utils.parseUnits("2", "gwei")
          };
        } catch (feeError) {
          console.warn("Failed to fetch fee data, using fallback:", feeError);
          gasSettings = { gasLimit: 100000, gasPrice: ethers.utils.parseUnits("1", "gwei") };
        }
        const tx = await contract.withdraw(gasSettings);
        await tx.wait();
        logConnect("Withdrawal complete");
      } catch (error) {
        console.error("Withdrawal error:", error);
        errorEl.textContent = error.code === -32603 || error.message.includes("insufficient funds") 
          ? "Withdrawal failed: Insufficient funds for gas. Add VC to your wallet." 
          : "Withdrawal failed: " + error.message;
        logConnect(`Withdrawal error: ${error.message}`);
        updateUI();
      }
    }

    // Share to X
    function shareToX() {
      if (!lastWin) return;
      const text = `I won ${lastWin.payout} VIN on VinuHub! ðŸª™ #VinuChain`;
      const url = `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`;
      window.open(url, "_blank");
    }

    // Set up event listeners
    function setupEventListeners() {
      if (!contract || !account) return;
      logConnect("Setting up event listeners");
      try {
        contract.on("FlipResult", (player, heads, won, bet, payout) => {
          logConnect(`FlipResult event: player=${player}, won=${won}`);
          if (player.toLowerCase() === account.toLowerCase()) {
            coinSide = heads ? "heads" : "tails"; // Set final coin side
            const result = { heads, won, bet: ethers.utils.formatEther(bet), payout: ethers.utils.formatEther(payout) };
            history = [...history.slice(-4), result];
            if (won) {
              lastWin = { player, payout: ethers.utils.formatEther(payout), timestamp: Date.now() };
              leaderboard = [...leaderboard.filter(entry => entry.player !== player).slice(-4), lastWin].slice(-5);
              confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ["#ffffff"] });
              playWinSound();
            } else {
              lastWin = null;
              playLossSound();
            }
            resultEl.innerHTML = `
              <p class="text-sm sm:text-base">${result.heads ? "Heads" : "Tails"} - ${result.won ? "You Won!" : "You Lost"}</p>
              <p class="text-sm sm:text-base">Bet: ${result.bet} VIN | Payout: ${result.payout} VIN</p>
            `;
            flipping = false;
            checkBalances();
            updateUI();
          } else if (won) {
            leaderboard = [...leaderboard.filter(entry => entry.player !== player).slice(-4), { player, payout: ethers.utils.formatEther(payout), timestamp: Date.now() }].slice(-5);
            localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
            updateUI();
          }
        });
        contract.on("Withdrawal", (player, amount) => {
          logConnect(`Withdrawal event: player=${player}, amount=${amount}`);
          if (player.toLowerCase() === account.toLowerCase()) {
            playerBalance = "0";
            resultEl.innerHTML = `<p class="text-sm sm:text-base">Withdrew ${ethers.utils.formatEther(amount)} VIN</p>`;
            lastWin = null;
            checkBalances();
            updateUI();
          }
        });
        logConnect("Event listeners set up");
      } catch (eventError) {
        console.error("Event listener error:", eventError);
        errorEl.textContent = "Failed to set up event listeners: " + eventError.message;
        logConnect(`Event listener error: ${eventError.message}`);
        updateUI();
      }
    }

    // Event handlers
    connectWalletBtn.addEventListener("click", connectWallet);
    disconnectWalletBtn.addEventListener("click", disconnectWallet);
    betAmountInput.addEventListener("input", debounce((e) => {
      betAmount = e.target.value;
      if (account) validateBet(betAmount);
      checkAllowance();
      updateUI();
    }, 300));
    setMaxBtn.addEventListener("click", () => {
      betAmount = maxBet;
      if (account) validateBet(betAmount);
      checkAllowance();
      updateUI();
    });
    chooseHeadsBtn.addEventListener("click", () => {
      choice = true;
      updateUI();
    });
    chooseTailsBtn.addEventListener("click", () => {
      choice = false;
      updateUI();
    });
    approveVinBtn.addEventListener("click", approveVin);
    flipCoinBtn.addEventListener("click", () => {
      if (!contract) return;
      if (history.length === 0) setupEventListeners();
      flipCoin();
    });
    withdrawBtn.addEventListener("click", () => {
      if (!contract) return;
      if (history.length === 0) setupEventListeners();
      withdraw();
    });
    shareXBtn.addEventListener("click", shareToX);

    // Initialize
    initialize();
  </script>
</body>
</html>
